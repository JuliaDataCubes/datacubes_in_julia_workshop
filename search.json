[
  {
    "objectID": "exercise_yaxarrays.html#dataset-download",
    "href": "exercise_yaxarrays.html#dataset-download",
    "title": "Exercise YAXArrays",
    "section": "Dataset download",
    "text": "Dataset download\n\nusing YAXArrays\nusing Zarr\nusing DiskArrays\nusing DimensionalData\nera5url = \"https://s3.bgc-jena.mpg.de:9000/deepextremes/v3/ERA5Cube.zarr\"\nera5 = Cube(era5url)\ntimedim = dimnum(era5, Ti)\nchunkinds =ones(Int64, length(size(era5)))\nchunks = eachchunk(era5)\nchunkinds[timedim] = size(chunks, timedim)-1\nlastchunk = chunks[chunkinds...]\ntimestart = first(dims(era5,Ti)[lastchunk[timedim]])\ntimeend = last(dims(era5,Ti))\nsub = era5[Ti=timestart..timeend, longitude=0..14.76,latitude=30.1..60]\n\n\n\n\n\nDatacubes in Julia",
    "crumbs": [
      "Home",
      "Exercises",
      "Exercise YAXArrays"
    ]
  },
  {
    "objectID": "rasterdata.html#loading-zarr-data-from-the-web",
    "href": "rasterdata.html#loading-zarr-data-from-the-web",
    "title": "Raster data handling",
    "section": "Loading Zarr data from the Web",
    "text": "Loading Zarr data from the Web\nThe data that we are working with is often available in the Zarr format. The Zarr format can be loaded from the cloud or from local computers."
  },
  {
    "objectID": "rasterdata.html#combining-multiple-tiff-files-into-a-data-cube",
    "href": "rasterdata.html#combining-multiple-tiff-files-into-a-data-cube",
    "title": "Raster data handling",
    "section": "Combining multiple Tiff files into a data cube",
    "text": "Combining multiple Tiff files into a data cube"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This site is the tutorial for raster data handling in Julia. This tutorial has been developed in the NFDI4Earth Measure 2.5.\n\nThis is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "intro-repl.html",
    "href": "intro-repl.html",
    "title": "Working in the REPL",
    "section": "",
    "text": "For a more in depth introduction and more tips and tricks see the REPL Mastery workshop from JuliaCon 2022.",
    "crumbs": [
      "Home",
      "Julia Introduction",
      "Working in the REPL"
    ]
  },
  {
    "objectID": "intro-repl.html#different-repl-modes",
    "href": "intro-repl.html#different-repl-modes",
    "title": "Working in the REPL",
    "section": "",
    "text": "For a more in depth introduction and more tips and tricks see the REPL Mastery workshop from JuliaCon 2022.",
    "crumbs": [
      "Home",
      "Julia Introduction",
      "Working in the REPL"
    ]
  },
  {
    "objectID": "chunking.html#how-to-deal-with-chunked-data",
    "href": "chunking.html#how-to-deal-with-chunked-data",
    "title": "Chunking: Why and how?",
    "section": "How to deal with chunked data?",
    "text": "How to deal with chunked data?"
  },
  {
    "objectID": "chunking.html#what-is-the-influence-of-chunking-on-my-analysis",
    "href": "chunking.html#what-is-the-influence-of-chunking-on-my-analysis",
    "title": "Chunking: Why and how?",
    "section": "What is the influence of chunking on my analysis?",
    "text": "What is the influence of chunking on my analysis?\n\nFurther reading\nSee the chunking tutorial at [Linas Tutorial] for an in depth explanation of chunking and to see the differences of different chunking regimes."
  },
  {
    "objectID": "intro_YAXArrays.html",
    "href": "intro_YAXArrays.html",
    "title": "General introduction to YAXArrays.jl and mapCube",
    "section": "",
    "text": "using Pkg\nPkg.activate(\".\")\nPkg.instantiate()\n\n  Activating project at `~/Documents/BigDatafromSpace2023_quarto`\nSo far we have only used mapslices in this tutorial. However, this can only cover very simple cases for a single input cube and computations on one or dimensions which either collapse or return the same dimension.\nusing DimensionalData, YAXArrays, Zarr, NetCDF\nusing GLMakie\nbucket = \"esdl-esdc-v3.0.2\"\nstore = \"esdc-16d-2.5deg-46x72x1440-3.0.2.zarr\"\npath = \"https://s3.bgc-jena.mpg.de:9000/\" * bucket * \"/\" * store\nc = Cube(open_dataset(zopen(path,consolidated=true,fill_as_missing=true)))\n\n#c = Cube(joinpath(tutorialdir,\"esdc_subset2.zarr\"))\n\n\n144×72×989×42 YAXArray{Union{Missing, Float32},4} with dimensions: \n  Dim{:lon} Sampled{Float64} -178.75:2.5:178.75 ForwardOrdered Regular Points,\n  Dim{:lat} Sampled{Float64} -88.75:2.5:88.75 ForwardOrdered Regular Points,\n  Ti Sampled{DateTime} DateTime[1979-01-09T00:00:00, …, 2021-12-27T00:00:00] ForwardOrdered Irregular Points,\n  Dim{:Variable} Categorical{String} String[sensible_heat, potential_evaporation, …, net_ecosystem_exchange, snow_sublimation] Unordered\nunits: mm d^-1\nTotal size: 1.6 GB"
  },
  {
    "objectID": "intro_YAXArrays.html#the-mapcube-function",
    "href": "intro_YAXArrays.html#the-mapcube-function",
    "title": "General introduction to YAXArrays.jl and mapCube",
    "section": "The mapCube function",
    "text": "The mapCube function\nis a generalization of mapslices, where you can annotate the exact signature of the function to be applied. For example the computation of the median over time can be written using mapCube. Here one hase to specify the dimension(s) that the user-defined function is going to operate on. For the computation of the median over time the only input dimension is time and there are no output dimensions as only a single value is returned. The user defined function passed to mapCube always has the signature f(outputs..., inputs...) and potentially followd by additional arguments and keyword args."
  },
  {
    "objectID": "intro_YAXArrays.html#apply-function-along-single-axis",
    "href": "intro_YAXArrays.html#apply-function-along-single-axis",
    "title": "General introduction to YAXArrays.jl and mapCube",
    "section": "Apply function along single Axis",
    "text": "Apply function along single Axis\n\nusing Statistics \nindims = InDims(\"time\")\noutdims = OutDims()\nfunction apply_median(xout, xin)\n    x = filter(!ismissing, xin)\n\n    x = filter(!isnan,x)\n    #@show x\n\n    #filter!(!ismissing, x)\n    xout[] = isempty(x) ? missing : median(x)\nend\n\napply_median (generic function with 1 method)\n\n\n\nmedians = mapCube(apply_median, c[Variable=Where(contains(\"temp\"))];indims, outdims)\n\n┌ Warning: (Dim{:region},) dims were not found in object.\n└ @ DimensionalData.Dimensions /home/fcremer/.julia/packages/DimensionalData/STtQw/src/Dimensions/primitives.jl:736\n\n\n\n144×72×3 YAXArray{Union{Missing, Float32},3} with dimensions: \n  Dim{:lon} Sampled{Float64} -178.75:2.5:178.75 ForwardOrdered Regular Points,\n  Dim{:lat} Sampled{Float64} -88.75:2.5:88.75 ForwardOrdered Regular Points,\n  Dim{:Variable} Categorical{String} String[\"max_air_temperature_2m\", \"air_temperature_2m\", \"min_air_temperature_2m\"] Unordered\nTotal size: 121.5 KB\n\n\n\n\n\nfig, ax, heat = heatmap(DimArray(medians[Variable=At(\"air_temperature_2m\")]))"
  },
  {
    "objectID": "intro_YAXArrays.html#apply-function-on-all-elements",
    "href": "intro_YAXArrays.html#apply-function-on-all-elements",
    "title": "General introduction to YAXArrays.jl and mapCube",
    "section": "Apply function on all elements",
    "text": "Apply function on all elements\n\nmedians_kelvin = map(x-&gt; x + 273.15, medians)\n\n\n144×72×3 YAXArray{Float64,3} with dimensions: \n  Dim{:lon} Sampled{Float64} -178.75:2.5:178.75 ForwardOrdered Regular Points,\n  Dim{:lat} Sampled{Float64} -88.75:2.5:88.75 ForwardOrdered Regular Points,\n  Dim{:Variable} Categorical{String} String[\"max_air_temperature_2m\", \"air_temperature_2m\", \"min_air_temperature_2m\"] Unordered\nTotal size: 243.0 KB\n\n\n\n\nThis function is applied lazily and only computed when the data is worked with. This could be a mapCube operation, saving the data to disk or plotting the data.\n\nheatmap(DimArray(medians_kelvin[Variable=At(\"air_temperature_2m\"), region=\"Italy\"]))\n\n┌ Warning: (Dim{:region},) dims were not found in object.\n└ @ DimensionalData.Dimensions /home/fcremer/.julia/packages/DimensionalData/STtQw/src/Dimensions/primitives.jl:736"
  },
  {
    "objectID": "intro_YAXArrays.html#arguments-for-inner-function-and-output-dimensions",
    "href": "intro_YAXArrays.html#arguments-for-inner-function-and-output-dimensions",
    "title": "General introduction to YAXArrays.jl and mapCube",
    "section": "Arguments for inner function and output dimensions",
    "text": "Arguments for inner function and output dimensions\nLet’s make a slightly more complex computation to demonstrate a case where multiple outputs are generated. For examples, imagine we want to normalize every time series (to zero mean and unit variance), but at the same time return the means and variances in a single dataset for later re-use:"
  },
  {
    "objectID": "intro_YAXArrays.html#apply-function-with-multiple-output-cubes",
    "href": "intro_YAXArrays.html#apply-function-with-multiple-output-cubes",
    "title": "General introduction to YAXArrays.jl and mapCube",
    "section": "Apply function with multiple output cubes",
    "text": "Apply function with multiple output cubes\n\nfunction norm(ts_out, mean_out, std_out, ts_in)\n    x = filter(!ismissing, ts_in)\n\n    tsshort = filter(!isnan,x)\n    if isempty(tsshort)\n        ts_out .= missing\n        mean_out[] = missing\n        std_out[] = missing\n    else\n        mean_out[] = mean(tsshort)\n        std_out[] = std(tsshort)\n        ts_out .= (ts_in .- mean_out[])./std_out[]\n    end\nend\n\nnorm (generic function with 1 method)\n\n\n\nusing NetCDF\nindims = InDims(\"Time\")\nod_ts = OutDims(\"Time\",path = \"./normalized_ts.zarr\",\n                backend=:zarr,overwrite=true)\nod_m = OutDims(path = \"./means.nc\",backend=:netcdf, overwrite=true)\nod_s = OutDims(path = \"./stds.nc\",backend=:netcdf, overwrite=true)\noutdims = (od_ts, od_m, od_s)\ntsnorm, means, stds = mapCube(norm,c[Variable=Where(contains(\"temp\"))],indims=indims, outdims=outdims);\n\n\nheatmap(DimArray(stds[Variable=At(\"air_temperature_2m\")]))"
  },
  {
    "objectID": "intro_YAXArrays.html#apply-function-on-moving-window",
    "href": "intro_YAXArrays.html#apply-function-on-moving-window",
    "title": "General introduction to YAXArrays.jl and mapCube",
    "section": "Apply function on moving window",
    "text": "Apply function on moving window\n\nfunction meanfilter(xout, xin)\n    if ismissing(xin[2,2])\n        xout .= missing\n    else\n    xout .= mean(skipmissing(xin))\n    end\nend\n\nmeanfilter (generic function with 1 method)\n\n\n\nindims = InDims(MovingWindow(\"lon\", 1,1),MovingWindow(\"lat\", 1, 1))\n\nInDims((MovingWindow(YAXArrays.ByName(\"lon\"), 1, 1), MovingWindow(YAXArrays.ByName(\"lat\"), 1, 1)), Array, (YAXArrays.DAT.AllMissing(),), missing)\n\n\n\nheatmap(DimArray(means[Variable=At(\"air_temperature_2m\")]))\n\n\nstds\n\n\nfilteredmeans = mapCube(meanfilter, means, indims=indims, outdims=OutDims())\n\n\n144×72×3 YAXArray{Union{Missing, Float32},3} with dimensions: \n  Dim{:lon} Sampled{Float64} -178.75:2.5:178.75 ForwardOrdered Regular Points,\n  Dim{:lat} Sampled{Float64} -88.75:2.5:88.75 ForwardOrdered Regular Points,\n  Dim{:Variable} Categorical{String} String[\"max_air_temperature_2m\", \"air_temperature_2m\", \"min_air_temperature_2m\"] Unordered\nTotal size: 121.5 KB\n\n\n\n\n\nheatmap(DimArray(filteredmeans[Variable=At(\"air_temperature_2m\")]))"
  },
  {
    "objectID": "intro_YAXArrays.html#define-new-output-dimensions",
    "href": "intro_YAXArrays.html#define-new-output-dimensions",
    "title": "General introduction to YAXArrays.jl and mapCube",
    "section": "Define new output dimensions",
    "text": "Define new output dimensions\n\nusing Dates\ndateformatfun(x) = Dates.format.(rata2datetime.(x), \"mm/dd/yyyy\")\ngpp = c[Variable=At(\"gross_primary_productivity\"),\n        time=Date(2001)..Date(2018,12,31), \n        lon=Near(11.3464),lat=Near(46.4946)]\nfig,ax, pl = lines(datetime2rata.(lookup(gpp, Ti).data),gpp.data)\nax.xtickformat = dateformatfun\nfig\n\n\n\n\n\n\n\n\nSo far the function applied here were very simple statistics. Just to stress again, that we are running arbitrary Julia code here, so for example if we want to use some package for time series decomposition like Forecast.jl:\n\nusing Forecast\nstlres = stl(gpp.data[:],46,robust=true,verbose=false,\n            timestamp=lookup(gpp, Ti).data)\n\nLoadError: UndefVarError: `tempbozen` not defined\n\n\n\nfunction plot_stlres(t, org, stlres)\n    fig = Figure()\n    axorg = Axis(fig[1,1], title=\"Original data\")\n    axseas = Axis(fig[2,1], title=\"Seasonal\")\n    axtrend = Axis(fig[3,1], title=\"Trend\")\n    axrem = Axis(fig[4,1], title=\"Remainder\")\n    lines!(axorg,t, org)\n    lines!(axseas, t, stlres.decomposition[!,:Seasonal])\n    lines!(axtrend, t, stlres.decomposition[!, :Trend])\n    lines!(axrem, t, stlres.decomposition[!, :Remainder])\n    hidexdecorations!.([axorg, axseas, axtrend], grid=false)\n    axrem.xtickformat = dateformatfun\n    fig\nend\n\nplot_stlres (generic function with 2 methods)\n\n\n\nt = datetime2rata.(stlres.decomposition[!,:Timestamp])\nplot_stlres(t, gpp, stlres)\n\n\n\n\n\n\n\n\nIn order to apply this over a full array we define the usual Trio: indims, outdims and the function to be applied. Here we create a new dimension for the output. There are 2 types of axes in YAXArrays, CategoricalAxis for unordered and RangeAxis for ordered dimensions. Here we create a categorical axis for our outputs. This means that inside the function the input array xin is a vector with of length n_timesteps and the output is a matrix of size n_timesteps x 3\n\nimport Logging\nLogging.disable_logging(Logging.Info)\nindims = InDims(\"time\")\noutdims = OutDims(\"time\",Dim{:Scale}([\"Seasonal\", \"Trend\", \"Remainder\"]), \n                    path = \"decomposed.zarr\",backend=:zarr, overwrite=true)\nfunction decompose_TS(xout, xin)\n    any(isnan,xin) && return xout .= missing\n    stlres = stl(xin,46,robust=false,verbose=false)\n    _,seas,trend,rem = eachcol(stlres.decomposition)\n    xout[:,1] = seas\n    xout[:,2] = trend\n    xout[:,3] = rem\nend\n\ndecompose_TS (generic function with 1 method)\n\n\n\nusing Logging\nLogging.disable_logging(Warn)\n\n\n@time dec = mapCube(decompose_TS, \n    c[Variable=At(\"gross_primary_productivity\"),\n        time=Date(2001)..Date(2018,12,31),\n        region=\"Italy\"],\n        #lon=Near(11.3464),lat=Near(46.4946)],\n    indims = indims,\n    outdims = outdims\n)\n\nProgress: 100%|█████████████████████████████████████████| Time: 0:02:11\n\n\n131.577868 seconds (204.94 M allocations: 576.936 GiB, 22.72% gc time)\n\n\n\n782×3×48×46 YAXArray{Union{Missing, Float32},4} with dimensions: \n  Ti Sampled{DateTime} DateTime[2001-01-05T00:00:00, …, 2017-12-31T00:00:00] ForwardOrdered Irregular Points,\n  Dim{:Scale} Categorical{String} String[\"Seasonal\", \"Trend\", \"Remainder\"] Unordered,\n  Dim{:lon} Sampled{Float64} 6.625:0.25:18.375 ForwardOrdered Regular Points,\n  Dim{:lat} Sampled{Float64} 46.875:-0.25:35.625 ReverseOrdered Regular Points\nTotal size: 19.76 MB\n\n\n\n\n\nLogging.disable_logging(Debug)\n\nLogLevel(-999)\n\n\n\nfig, axseas, heatyax = lines( datetime2rata.(lookup(dec, Ti).data),\n    dec[lon=Near(11.3464),lat=Near(46.4946)].data[:,1])\nfig\n\n\n\n\n\n\n\n\n\nlines!(datetime2rata.(lookup(dec, Ti).data),\n    stlres.decomposition[!, :Seasonal])\nfig\n\n\n\n\n\n\n\n\nYou see that the resulting array is a 4-dimensional array including the newly created axis. Lets do some plots:\n\n#Compute variance and plot a map of seasonal variance\nscalevar = mapslices(var,dec,dims=\"Time\")\nscalerange = mapslices(x-&gt;maximum(x) - minimum(x), dec, dims=\"Time\")\n\n\n3×48×46 YAXArray{Union{Missing, Float32},3} with dimensions: \n  Dim{:Scale} Categorical{String} String[\"Seasonal\", \"Trend\", \"Remainder\"] Unordered,\n  Dim{:lon} Sampled{Float64} 6.625:0.25:18.375 ForwardOrdered Regular Points,\n  Dim{:lat} Sampled{Float64} 46.875:-0.25:35.625 ReverseOrdered Regular Points\nTotal size: 25.88 KB\n\n\n\n\n\nheatmap(DimArray(scalerange[scale=At(\"Seasonal\")]))\n\n\n\n\n\n\n\n\n\nheatmap(DimArray(scalevar[scale=At(\"Remainder\")]))"
  },
  {
    "objectID": "intro_YAXArrays.html#interpolate-data-on-finer-grids",
    "href": "intro_YAXArrays.html#interpolate-data-on-finer-grids",
    "title": "General introduction to YAXArrays.jl and mapCube",
    "section": "Interpolate data on finer grids",
    "text": "Interpolate data on finer grids\n\nusing Revise,EarthDataLab, DimensionalData,Rasters, Interpolations\n#c = esdd()\nds = open_dataset(joinpath(tutorialdir,\"esdc_subset2.zarr\"))\ntair = ds.air_temperature_2m\n\nnewlons = -179.95:0.1:179.95\nnewlats = -89.95:0.1:89.95\n\n#Option 1:\ntair1 = spatialinterp(tair,newlons,newlats, order =Quadratic())\n\ntair1[lon=10..15, lat=50..60]\n\ntair1italy = tair1[region=\"Italy\",time=Near(DateTime(2015,6,1))]\n\n\nheatmap(DimArray(tair[region=\"Italy\", time=Near(DateTime(2015,6,1))]))\n\n\n\n\n\n\n\n\n\nfiginterp, interpax, interpheat = heatmap(DimArray(tair1italy))\n\n\n\n\n\n\n\n\n\nusing Dates\nnewtimes = DateTime(1979):Day(1):DateTime(2021,12,31)\ntair2 = interpolatecube(tair,Dict(:time=&gt;newtimes), order=Dict(:time=&gt;Quadratic()))\ntair2Jan = tair2[time=DateTime(2001)..DateTime(2002,1,31), lon=Near(11.3464),lat=Near(46.4946)]\ntairJan = tair[time=DateTime(2001)..DateTime(2002,1,31), lon=Near(11.3464),lat=Near(46.4946)]\n\nfig, ax, pl = scatter(datetime2rata.(lookup(tair2Jan, Ti).data), tair2Jan.data[:],label=\"Interpolated\")\nscatter!(datetime2rata.(lookup(tairJan, Ti).data), tairJan.data[:], label=\"Original\")\nax.xtickformat = dateformatfun\naxislegend(ax)\nfig\n\nii = [(:time, 3)]\nai = nothing\nai = nothing\nai = 1\nii[ai] = (:time, 3)\nintorder = (NoInterp(), NoInterp(), Quadratic(Line(OnGrid())))"
  },
  {
    "objectID": "intro_YAXArrays.html#use-python-or-r-in-inner-function",
    "href": "intro_YAXArrays.html#use-python-or-r-in-inner-function",
    "title": "General introduction to YAXArrays.jl and mapCube",
    "section": "Use Python or R in inner function",
    "text": "Use Python or R in inner function\n\nusing PyCall\nscipyndimage = pyimport(\"scipy.ndimage\")\n\nPyObject &lt;module 'scipy.ndimage' from '/home/fcremer/.julia/conda/3/lib/python3.9/site-packages/scipy/ndimage/__init__.py'&gt;\n\n\n\nfunction gaussian_smooth(xout, xin)\n    missinds = ismissing.(xin)\n    smooth = scipyndimage.gaussian_filter(xin[.!missinds], sigma=4)\n    xout[.!missinds] .= smooth\nend\n\ngaussian_smooth (generic function with 1 method)\n\n\n\ngpp_bozen_2010 = c[lon=Near(11.3464),lat=Near(46.4946),\n    time = DateTime(2010)..DateTime(2011),\n    Variable=At(\"gross_primary_productivity\")]\n\n\n46-element YAXArray{Union{Missing, Float32},1} with dimensions: \n  Ti Sampled{DateTime} DateTime[2010-01-05T00:00:00, …, 2010-12-31T00:00:00] ForwardOrdered Irregular Points\nunits: W m-2\nTotal size: 184.0 bytes\n\n\n\n\n\nsmoothcube = mapCube(gaussian_smooth, gpp_bozen_2010, indims=InDims(\"time\"), outdims=OutDims(\"time\"))\n\n\n46-element YAXArray{Union{Missing, Float32},1} with dimensions: \n  Ti Sampled{DateTime} DateTime[2010-01-05T00:00:00, …, 2010-12-31T00:00:00] ForwardOrdered Irregular Points\nTotal size: 184.0 bytes\n\n\n\n\n\nfig, ax, l = lines(datetime2rata.(lookup(gpp_bozen_2010, Ti).data), gpp_bozen_2010[:], label=\"Original\")\nlines!(ax,datetime2rata.(lookup(smoothcube, Ti).data), smoothcube[:], label=\"Smooth\")\nax.xtickformat= dateformatfun\naxislegend(ax)\nfig"
  },
  {
    "objectID": "intro_YAXArrays.html#parellelize-the-data-processing",
    "href": "intro_YAXArrays.html#parellelize-the-data-processing",
    "title": "General introduction to YAXArrays.jl and mapCube",
    "section": "Parellelize the data processing",
    "text": "Parellelize the data processing"
  },
  {
    "objectID": "intro_YAXArrays.html#easy-parallelization-on-multiple-cores-and-multiple-nodes",
    "href": "intro_YAXArrays.html#easy-parallelization-on-multiple-cores-and-multiple-nodes",
    "title": "General introduction to YAXArrays.jl and mapCube",
    "section": "Easy parallelization on multiple cores and multiple nodes¶",
    "text": "Easy parallelization on multiple cores and multiple nodes¶\n\nUse threads on a single computer\nUse Distributed on multiple computers\nWorks also with ClusterManagers like SLURM\n\n\nusing Distributed, Zarr\naddprocs(4);\n\n\n@everywhere begin \n    using Pkg\n    Pkg.activate(\".\")\n    Pkg.instantiate()\n    #Pkg.status()\n    using YAXArrays, Statistics, NetCDF, Zarr\nend\n\n  Activating project at `~/Documents/conferences/202310_Bozen_OEMC_GW23`\n\n\n      From worker 12:     Activating project at `~/Documents/conferences/202310_Bozen_OEMC_GW23`\n      From worker 13:     Activating project at `~/Documents/conferences/202310_Bozen_OEMC_GW23`\n      From worker 10:     Activating project at `~/Documents/conferences/202310_Bozen_OEMC_GW23`\n      From worker 11:     Activating project at `~/Documents/conferences/202310_Bozen_OEMC_GW23`"
  },
  {
    "objectID": "intro-pkg.html",
    "href": "intro-pkg.html",
    "title": "Introduction to the Package Manager",
    "section": "",
    "text": "This is only a small glimpse in the Julia package manager. For an in depth intro see Pkg.jl and Julia Environments for Beginners.",
    "crumbs": [
      "Home",
      "Julia Introduction",
      "Package Manager"
    ]
  },
  {
    "objectID": "intro-pkg.html#activating-your-environment",
    "href": "intro-pkg.html#activating-your-environment",
    "title": "Introduction to the Package Manager",
    "section": "Activating your environment",
    "text": "Activating your environment\nactivate .",
    "crumbs": [
      "Home",
      "Julia Introduction",
      "Package Manager"
    ]
  },
  {
    "objectID": "intro-pkg.html#package-handling",
    "href": "intro-pkg.html#package-handling",
    "title": "Introduction to the Package Manager",
    "section": "Package handling",
    "text": "Package handling\n```julia add Example\n\nFurther reading\n\nPkg.jl documentation\nPkg.jl and Julia Environments for Beginners\nModern Julia workflows on environments",
    "crumbs": [
      "Home",
      "Julia Introduction",
      "Package Manager"
    ]
  },
  {
    "objectID": "intro_ndarrays.html#data-cubes",
    "href": "intro_ndarrays.html#data-cubes",
    "title": "Basics of multidimensional data analysis",
    "section": "Data cubes",
    "text": "Data cubes\n\nEarth System Data Cube",
    "crumbs": [
      "Home",
      "Basics of multidimensional data analysis"
    ]
  },
  {
    "objectID": "intro_ndarrays.html#data-formats",
    "href": "intro_ndarrays.html#data-formats",
    "title": "Basics of multidimensional data analysis",
    "section": "Data formats",
    "text": "Data formats\n\nGeotiff\nZarr\nNetCDF\n…",
    "crumbs": [
      "Home",
      "Basics of multidimensional data analysis"
    ]
  },
  {
    "objectID": "intro_ndarrays.html#chunking",
    "href": "intro_ndarrays.html#chunking",
    "title": "Basics of multidimensional data analysis",
    "section": "Chunking",
    "text": "Chunking\n\n\n\n\n\n\n\n\nSpatial chunking\n\n\n\n\n\n\n\nBox chunking\n\n\n\n\n\n\nFigure 1: Different chunking structures",
    "crumbs": [
      "Home",
      "Basics of multidimensional data analysis"
    ]
  },
  {
    "objectID": "intro_ndarrays.html#pyramids",
    "href": "intro_ndarrays.html#pyramids",
    "title": "Basics of multidimensional data analysis",
    "section": "Pyramids",
    "text": "Pyramids\n\nusing PyramidScheme\nusing Rasters, RasterDataSources\nusing ArchGDAL\nrastas = Raster(CHELSA{Climate},:tas, lazy=true, month=1)\nrastasscale = rastas.metadata[\"scale\"] .* rastas .+ rastas.metadata[\"offset\"]\npyrtas = Pyramid(rastasscale)\nusing GLMakie\nplot(pyrtas, colormap=Reverse(:RdYlBu))",
    "crumbs": [
      "Home",
      "Basics of multidimensional data analysis"
    ]
  },
  {
    "objectID": "intro_ndarrays.html#pyramid-example",
    "href": "intro_ndarrays.html#pyramid-example",
    "title": "Basics of multidimensional data analysis",
    "section": "Pyramid example",
    "text": "Pyramid example\n\n\n\n\n\nDatacubes in Julia",
    "crumbs": [
      "Home",
      "Basics of multidimensional data analysis"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Geospatial data cubes in Julia workshop",
    "section": "",
    "text": "This is the website of the “Geospatial data cubes in Julia workshop”.\nIn this tutorial we will explore how to analyse raster data which is larger than RAM."
  },
  {
    "objectID": "index.html#preparation",
    "href": "index.html#preparation",
    "title": "Geospatial data cubes in Julia workshop",
    "section": "Preparation",
    "text": "Preparation\nTo participate in the hands-on parts of the tutorial please install Julia on your device and instantiate a first environment to make sure that most Julia packages are already downloaded on your computer.\n\nInstallation of Julia\nWe recommend to use the juliaup installer for julia.\n\nWindowsMac or Linux\n\n\nYou can install juliaup via the windows store or by executing\nwinget install julia -s msstore\n\n\nTo install juliaup in Linux or Mac execute the following in a shell\ncurl -fsSL https://install.julialang.org | sh\n\n\n\n\n\nInstantiation of an initial environment\nFor the workshop we are going to use the environment that is available of the examples folder.\n\nManual downloadUse git\n\n\nYou can download the Project.toml file from https://github.com/JuliaDataCubes/datacubes_in_julia_workshop/blob/main/examples/Project.toml manually and save it in a new folder. Then change in a terminal to this folder.\n\n\nUse git to download the whole workshop material.\ngit clone https://github.com/JuliaDataCubes/datacubes_in_julia_workshop/\nChange to the examples folder in the datacubes_in_julia_workshop folder.\n\n\n\nNow that we have the Project.toml file downloaded we can run the following line in the terminal from the folder in which the Project.toml is located.\njulia -e 'using Pkg;Pkg.activate(\".\");Pkg.resolve();Pkg.precompile()'"
  },
  {
    "objectID": "index.html#day-1",
    "href": "index.html#day-1",
    "title": "Geospatial data cubes in Julia workshop",
    "section": "Day 1",
    "text": "Day 1\n\n\n\nTime\nTopic\n\n\n\n\n9:00\nIntroduction to Datacube analysis\n\n\n9:30\nIntroduction to Julia\n\n\n10:30\nBreak\n\n\n10:50\nExercise: Time series analysis + plotting"
  },
  {
    "objectID": "index.html#day-2",
    "href": "index.html#day-2",
    "title": "Geospatial data cubes in Julia workshop",
    "section": "Day 2",
    "text": "Day 2\n\n\n\nTime\nTopic\n\n\n\n\n9:00\nIntroduction to YAXArrays.jl\n\n\n9:45\nExercise: YAXArrays\n\n\n10:15\nBreak\n\n\n10:30\nExcursion: Datacubes in python\n\n\n10:45\nData preparation\n\n\n11:15\nPyramidScheme.jl"
  },
  {
    "objectID": "intro_julia.html#variables",
    "href": "intro_julia.html#variables",
    "title": "Introduction to Julia",
    "section": "Variables",
    "text": "Variables\n\n# Variables are names (tags, stickers) for Julia objects\nx = 2\ny = x\nx = 3\nx, y \n\n(3, 2)",
    "crumbs": [
      "Home",
      "Julia Introduction",
      "Introduction to Julia"
    ]
  },
  {
    "objectID": "intro_julia.html#data-types",
    "href": "intro_julia.html#data-types",
    "title": "Introduction to Julia",
    "section": "Data types",
    "text": "Data types\n\nBuilt-in Data types\n\n#Numeric data types\nfor T in (UInt8, UInt16, UInt32, UInt64, Int8, Int16, Int32, Int64, \n          Float16, Float32, Float64, ComplexF16, ComplexF32, ComplexF64)\n    @show T(5)\nend\n\nT(5) = 0x05\nT(5) = 0x0005\nT(5) = 0x00000005\nT(5) = 0x0000000000000005\nT(5) = 5\nT(5) = 5\nT(5) = 5\nT(5) = 5\nT(5) = Float16(5.0)\nT(5) = 5.0f0\nT(5) = 5.0\nT(5) = Float16(5.0) + Float16(0.0)im\nT(5) = 5.0f0 + 0.0f0im\nT(5) = 5.0 + 0.0im\n\n\n\n@show typeof([1,2,3])\n@show typeof([1.0,2.0,3.0])\n\ntypeof([1, 2, 3]) = Vector{Int64}\ntypeof([1.0, 2.0, 3.0]) = Vector{Float64}\n\n\n\nVector{Float64} (alias for Array{Float64, 1})\n\n\n\n\n\nCustom data types\nstructs are basic types composing several fields into a single object.\n\nstruct PointF\nx::Float64\ny::Float64\nend\np = PointF(2.0,3.0)\n\nPointF(2.0, 3.0)\n\n\nThe fields of a struct may or may not be typed\n\nstruct PointUntyped\nx\ny\nend\np = PointUntyped(2.f0, 3)\n\nPointUntyped(2.0f0, 3)\n\n\n\nPointUntyped(\"Hallo\", sin)\n\nPointUntyped(\"Hallo\", sin)\n\n\nParametric types can be used to generic specialized code for a variety of field types.\n\nstruct Point{T&lt;:Number}\nx::T\ny::T\nend\np = Point(3.f0,2.f0)\n\nPoint{Float32}(3.0f0, 2.0f0)",
    "crumbs": [
      "Home",
      "Julia Introduction",
      "Introduction to Julia"
    ]
  },
  {
    "objectID": "intro_julia.html#loops",
    "href": "intro_julia.html#loops",
    "title": "Introduction to Julia",
    "section": "Loops",
    "text": "Loops\nLoops are written using the for keyword and process any object implementing the iteration interface\n\nfor i in 1:3\n    println(i)\nend\n\nfor letter in \"hello\"\n    println(letter)\nend\n\n1\n2\n3\nh\ne\nl\nl\no",
    "crumbs": [
      "Home",
      "Julia Introduction",
      "Introduction to Julia"
    ]
  },
  {
    "objectID": "intro_julia.html#functions",
    "href": "intro_julia.html#functions",
    "title": "Introduction to Julia",
    "section": "Functions",
    "text": "Functions\nThere are 3 ways to define functions in Julia:\nLong form:\n\nfunction f1(x, y)\n    return x+y\nend\n\nf1 (generic function with 1 method)\n\n\nNote that the return keyword is optional. If it is missing, a function always returns the result of the last statement.\nShort form:\n\nf2(x, y) = x + y\n\nf2 (generic function with 1 method)\n\n\nVery useful for writing short one-liners.\nAnonymous functions (similar to lambdas in python), will be important in the Functional Programming section:\n\nf3 = (x,y) -&gt; x + y\n\n#15 (generic function with 1 method)\n\n\nThey all define the same function:\n\nf1(1,2) == f2(1,2) == f3(1,2) == 3\n\ntrue",
    "crumbs": [
      "Home",
      "Julia Introduction",
      "Introduction to Julia"
    ]
  },
  {
    "objectID": "intro_julia.html#multiple-dispatch",
    "href": "intro_julia.html#multiple-dispatch",
    "title": "Introduction to Julia",
    "section": "Multiple Dispatch",
    "text": "Multiple Dispatch\nIn object-oriented programming languages methods (behavior) are part of the class namespace itself and can be used to implement generic behavior.\nclass Point():\n    def __init__(self,x,y):\n        self.x = x\n        self.y = y\n\n    def abs(self):\n        return self.x*self.x + self.y*self.y\n\np = Point(3,2)\np.abs()\nIn Julia, functions are first-class objects and can have multiple methods for different combinations of argument types.\n\nabsolute(p::Point) = p.x^2 + p.y^2\n\nabsolute (generic function with 1 method)\n\n\nThis defines a new function absolute with a single method\n\nmethods(absolute)\n\n# 1 method for generic function absolute from \u001b[35mMain\u001b[39m: absolute(p::Point) in Main at In[21]:1 \n\n\n\n@show absolute(Point(2,3))\n@show absolute(Point(2.0,3.0))\n\nabsolute(Point(2, 3)) = 13\nabsolute(Point(2.0, 3.0)) = 13.0\n\n\n13.0\n\n\nIn addition to defining new functions, existing functions can be extended to work for our custom data types:\n\nimport Base: +, -, *, /, zero, one, oneunit\n+(p1::Point, p2::Point) = Point(p1.x+p2.x, p1.y+p2.y)\n-(p1::Point, p2::Point) = Point(p1.x-p2.x, p1.y-p2.y)\n*(x::Number, p::Point) = Point(x*p.x, x*p.y)\n/(p::Point,x::Number) = Point(p.x/x,p.y/x)\n-(p::Point) = Point(-p.x,-p.y)\nzero(x::Point{T}) where T = zero(typeof(x))\nzero(::Type{Point{T}}) where T = Point(zero(T),zero(T))\none(x::Point{T}) where T = one(typeof(x))\none(::Type{Point{T}}) where T = Point(one(T),one(T))\nPoint{T}(p::Point) where T = Point{T}(T(p.x),T(p.y))\n\nNow that we have defined some basic math around the Point type we can use a lot of generic behavior:\n\n#Create zero matrix of Points\nzeros(Point{Float64},3,2)\n\n3×2 Matrix{Point{Float64}}:\n Point{Float64}(0.0, 0.0)  Point{Float64}(0.0, 0.0)\n Point{Float64}(0.0, 0.0)  Point{Float64}(0.0, 0.0)\n Point{Float64}(0.0, 0.0)  Point{Float64}(0.0, 0.0)\n\n\n\n#Diagonal matrices\npointvec = (1:3) .* ones(Point{Float64})\n\n3-element Vector{Point{Float64}}:\n Point{Float64}(1.0, 1.0)\n Point{Float64}(2.0, 2.0)\n Point{Float64}(3.0, 3.0)\n\n\n\nusing LinearAlgebra\ndiagm(0=&gt;pointvec)\n\n3×3 Matrix{Point{Float64}}:\n Point{Float64}(1.0, 1.0)  Point{Float64}(0.0, 0.0)  Point{Float64}(0.0, 0.0)\n Point{Float64}(0.0, 0.0)  Point{Float64}(2.0, 2.0)  Point{Float64}(0.0, 0.0)\n Point{Float64}(0.0, 0.0)  Point{Float64}(0.0, 0.0)  Point{Float64}(3.0, 3.0)\n\n\n\nrand(4,5) * ones(Point{Float64},5,2)\n\n4×2 Matrix{Point{Float64}}:\n Point{Float64}(3.54226, 3.54226)  Point{Float64}(3.54226, 3.54226)\n Point{Float64}(2.69291, 2.69291)  Point{Float64}(2.69291, 2.69291)\n Point{Float64}(3.88627, 3.88627)  Point{Float64}(3.88627, 3.88627)\n Point{Float64}(2.15169, 2.15169)  Point{Float64}(2.15169, 2.15169)\n\n\n\nrange(Point(-1.0,-2.0),Point(3.0,4.0),length=10)\n\n10-element LinRange{Point{Float64}, Int64}:\n Point{Float64}(-1.0, -2.0), …, Point{Float64}(3.0, 4.0)",
    "crumbs": [
      "Home",
      "Julia Introduction",
      "Introduction to Julia"
    ]
  },
  {
    "objectID": "intro_julia.html#differences-between-broadcast-and-map",
    "href": "intro_julia.html#differences-between-broadcast-and-map",
    "title": "Introduction to Julia",
    "section": "Differences between broadcast and map",
    "text": "Differences between broadcast and map\nFor single-argument functions there is no difference between map and broadcast. However, the functions differe in behavior when mutiple arguments are passed:\n\na = [0.1, 0.2, 0.3]\nb = [1.0 2.0 3.0]\n@show size(a)\n@show size(b)\n@show map(+,a,b)\n@show broadcast(+,a,b)\n@show a .+ b\nnothing\n\nsize(a) = (3,)\nsize(b) = (1, 3)\nmap(+, a, b) = [1.1, 2.2, 3.3]\nbroadcast(+, a, b) = [1.1 2.1 3.1; 1.2 2.2 3.2; 1.3 2.3 3.3]\na .+ b = [1.1 2.1 3.1; 1.2 2.2 3.2; 1.3 2.3 3.3]\n\n\nmap - iterates over all arguments separately, and passing them one by one to the applied function - agnostic of array shapes\nbroadcast - is dimension-aware - matches lengths of arrays along each array dimension - expanding dimensions of length 1 or non-existing dimensions at the end\nIn most cases one uses broadcast because it is easier to type using the dot-notation.\n\nreduce and foldl\n\nreduce(+,1:10)\n\n55\n\n\nWhat is happening behind the scenes?\n\nfunction myplus(x,y)\n    @show x,y\n    return x+y\nend\nreduce(myplus,1:10)\n\n(x, y) = (1, 2)\n(x, y) = (3, 3)\n(x, y) = (6, 4)\n(x, y) = (10, 5)\n(x, y) = (15, 6)\n(x, y) = (21, 7)\n(x, y) = (28, 8)\n(x, y) = (36, 9)\n(x, y) = (45, 10)\n\n\n55\n\n\nfoldl is very similar to reduce, but with left-associativty guaranteed (all elements of the array will be processed strictly in order), makes parallelization impossible.\nExample task: find the longest streak of true values in a Bool array.\n\nfunction streak(oldstate,newvalue)\n    maxstreak, currentstreak = oldstate\n    if newvalue #We extend the streak by 1\n        currentstreak += 1\n        maxstreak = max(currentstreak, maxstreak)\n    else\n        currentstreak = 0\n    end\n    return (maxstreak,currentstreak)\nend\nx = rand(Bool,1000)\nfoldl(streak,x,init=(0,0))\n\n(10, 1)\n\n\nmapreduce and mapfoldl combine both map and reduce. For example, to compute the sum of squares of a vector one can do:\n\nr = rand(1000)\nmapreduce(x-&gt;x*x,+,r)\n\n347.6218887354608\n\n\nTo compute the longest streak of random numbers larger than 0.9 we could do:\n\nmapfoldl(&gt;(0.1),streak,r,init=(0,0))\n\n(38, 0)",
    "crumbs": [
      "Home",
      "Julia Introduction",
      "Introduction to Julia"
    ]
  }
]