[
  {
    "objectID": "rasterdata.html#loading-zarr-data-from-the-web",
    "href": "rasterdata.html#loading-zarr-data-from-the-web",
    "title": "Raster data handling",
    "section": "Loading Zarr data from the Web",
    "text": "Loading Zarr data from the Web\nThe data that we are working with is often available in the Zarr format. The Zarr format can be loaded from the cloud or from local computers.",
    "crumbs": [
      "Home",
      "Julia Geo Ecosystem",
      "Raster data handling"
    ]
  },
  {
    "objectID": "rasterdata.html#combining-multiple-tiff-files-into-a-data-cube",
    "href": "rasterdata.html#combining-multiple-tiff-files-into-a-data-cube",
    "title": "Raster data handling",
    "section": "Combining multiple Tiff files into a data cube",
    "text": "Combining multiple Tiff files into a data cube",
    "crumbs": [
      "Home",
      "Julia Geo Ecosystem",
      "Raster data handling"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This site is the tutorial for raster data handling in Julia. This tutorial has been developed in the NFDI4Earth Measure 2.5.\n\nThis is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "intro-repl.html",
    "href": "intro-repl.html",
    "title": "Working in the REPL",
    "section": "",
    "text": "For a more in depth introduction and more tips and tricks see the REPL Mastery workshop from JuliaCon 2022.",
    "crumbs": [
      "Home",
      "Julia Introduction",
      "Working in the REPL"
    ]
  },
  {
    "objectID": "intro-repl.html#different-repl-modes",
    "href": "intro-repl.html#different-repl-modes",
    "title": "Working in the REPL",
    "section": "",
    "text": "For a more in depth introduction and more tips and tricks see the REPL Mastery workshop from JuliaCon 2022.",
    "crumbs": [
      "Home",
      "Julia Introduction",
      "Working in the REPL"
    ]
  },
  {
    "objectID": "chunking.html#how-to-deal-with-chunked-data",
    "href": "chunking.html#how-to-deal-with-chunked-data",
    "title": "Chunking: Why and how?",
    "section": "How to deal with chunked data?",
    "text": "How to deal with chunked data?",
    "crumbs": [
      "Home",
      "Raster data handling",
      "Chunking: Why and how?"
    ]
  },
  {
    "objectID": "chunking.html#what-is-the-influence-of-chunking-on-my-analysis",
    "href": "chunking.html#what-is-the-influence-of-chunking-on-my-analysis",
    "title": "Chunking: Why and how?",
    "section": "What is the influence of chunking on my analysis?",
    "text": "What is the influence of chunking on my analysis?\n\nFurther reading\nSee the chunking tutorial at [Linas Tutorial] for an in depth explanation of chunking and to see the differences of different chunking regimes.",
    "crumbs": [
      "Home",
      "Raster data handling",
      "Chunking: Why and how?"
    ]
  },
  {
    "objectID": "intro_YAXArrays.html",
    "href": "intro_YAXArrays.html",
    "title": "General introduction to YAXArrays.jl and mapCube",
    "section": "",
    "text": "using Pkg\nPkg.activate(\".\")\nPkg.instantiate()\n\n  Activating project at `~/Documents/BigDatafromSpace2023_quarto`\nSo far we have only used mapslices in this tutorial. However, this can only cover very simple cases for a single input cube and computations on one or dimensions which either collapse or return the same dimension.\nusing DimensionalData, YAXArrays, Zarr, NetCDF\nusing GLMakie\nbucket = \"esdl-esdc-v3.0.2\"\nstore = \"esdc-16d-2.5deg-46x72x1440-3.0.2.zarr\"\npath = \"https://s3.bgc-jena.mpg.de:9000/\" * bucket * \"/\" * store\nc = Cube(open_dataset(zopen(path,consolidated=true,fill_as_missing=true)))\n\n#c = Cube(joinpath(tutorialdir,\"esdc_subset2.zarr\"))\n\n\n144×72×989×42 YAXArray{Union{Missing, Float32},4} with dimensions: \n  Dim{:lon} Sampled{Float64} -178.75:2.5:178.75 ForwardOrdered Regular Points,\n  Dim{:lat} Sampled{Float64} -88.75:2.5:88.75 ForwardOrdered Regular Points,\n  Ti Sampled{DateTime} DateTime[1979-01-09T00:00:00, …, 2021-12-27T00:00:00] ForwardOrdered Irregular Points,\n  Dim{:Variable} Categorical{String} String[sensible_heat, potential_evaporation, …, net_ecosystem_exchange, snow_sublimation] Unordered\nunits: mm d^-1\nTotal size: 1.6 GB"
  },
  {
    "objectID": "intro_YAXArrays.html#the-mapcube-function",
    "href": "intro_YAXArrays.html#the-mapcube-function",
    "title": "General introduction to YAXArrays.jl and mapCube",
    "section": "The mapCube function",
    "text": "The mapCube function\nis a generalization of mapslices, where you can annotate the exact signature of the function to be applied. For example the computation of the median over time can be written using mapCube. Here one hase to specify the dimension(s) that the user-defined function is going to operate on. For the computation of the median over time the only input dimension is time and there are no output dimensions as only a single value is returned. The user defined function passed to mapCube always has the signature f(outputs..., inputs...) and potentially followd by additional arguments and keyword args."
  },
  {
    "objectID": "intro_YAXArrays.html#apply-function-along-single-axis",
    "href": "intro_YAXArrays.html#apply-function-along-single-axis",
    "title": "General introduction to YAXArrays.jl and mapCube",
    "section": "Apply function along single Axis",
    "text": "Apply function along single Axis\n\nusing Statistics \nindims = InDims(\"time\")\noutdims = OutDims()\nfunction apply_median(xout, xin)\n    x = filter(!ismissing, xin)\n\n    x = filter(!isnan,x)\n    #@show x\n\n    #filter!(!ismissing, x)\n    xout[] = isempty(x) ? missing : median(x)\nend\n\napply_median (generic function with 1 method)\n\n\n\nmedians = mapCube(apply_median, c[Variable=Where(contains(\"temp\"))];indims, outdims)\n\n┌ Warning: (Dim{:region},) dims were not found in object.\n└ @ DimensionalData.Dimensions /home/fcremer/.julia/packages/DimensionalData/STtQw/src/Dimensions/primitives.jl:736\n\n\n\n144×72×3 YAXArray{Union{Missing, Float32},3} with dimensions: \n  Dim{:lon} Sampled{Float64} -178.75:2.5:178.75 ForwardOrdered Regular Points,\n  Dim{:lat} Sampled{Float64} -88.75:2.5:88.75 ForwardOrdered Regular Points,\n  Dim{:Variable} Categorical{String} String[\"max_air_temperature_2m\", \"air_temperature_2m\", \"min_air_temperature_2m\"] Unordered\nTotal size: 121.5 KB\n\n\n\n\n\nfig, ax, heat = heatmap(DimArray(medians[Variable=At(\"air_temperature_2m\")]))"
  },
  {
    "objectID": "intro_YAXArrays.html#apply-function-on-all-elements",
    "href": "intro_YAXArrays.html#apply-function-on-all-elements",
    "title": "General introduction to YAXArrays.jl and mapCube",
    "section": "Apply function on all elements",
    "text": "Apply function on all elements\n\nmedians_kelvin = map(x-&gt; x + 273.15, medians)\n\n\n144×72×3 YAXArray{Float64,3} with dimensions: \n  Dim{:lon} Sampled{Float64} -178.75:2.5:178.75 ForwardOrdered Regular Points,\n  Dim{:lat} Sampled{Float64} -88.75:2.5:88.75 ForwardOrdered Regular Points,\n  Dim{:Variable} Categorical{String} String[\"max_air_temperature_2m\", \"air_temperature_2m\", \"min_air_temperature_2m\"] Unordered\nTotal size: 243.0 KB\n\n\n\n\nThis function is applied lazily and only computed when the data is worked with. This could be a mapCube operation, saving the data to disk or plotting the data.\n\nheatmap(DimArray(medians_kelvin[Variable=At(\"air_temperature_2m\"), region=\"Italy\"]))\n\n┌ Warning: (Dim{:region},) dims were not found in object.\n└ @ DimensionalData.Dimensions /home/fcremer/.julia/packages/DimensionalData/STtQw/src/Dimensions/primitives.jl:736"
  },
  {
    "objectID": "intro_YAXArrays.html#arguments-for-inner-function-and-output-dimensions",
    "href": "intro_YAXArrays.html#arguments-for-inner-function-and-output-dimensions",
    "title": "General introduction to YAXArrays.jl and mapCube",
    "section": "Arguments for inner function and output dimensions",
    "text": "Arguments for inner function and output dimensions\nLet’s make a slightly more complex computation to demonstrate a case where multiple outputs are generated. For examples, imagine we want to normalize every time series (to zero mean and unit variance), but at the same time return the means and variances in a single dataset for later re-use:"
  },
  {
    "objectID": "intro_YAXArrays.html#apply-function-with-multiple-output-cubes",
    "href": "intro_YAXArrays.html#apply-function-with-multiple-output-cubes",
    "title": "General introduction to YAXArrays.jl and mapCube",
    "section": "Apply function with multiple output cubes",
    "text": "Apply function with multiple output cubes\n\nfunction norm(ts_out, mean_out, std_out, ts_in)\n    x = filter(!ismissing, ts_in)\n\n    tsshort = filter(!isnan,x)\n    if isempty(tsshort)\n        ts_out .= missing\n        mean_out[] = missing\n        std_out[] = missing\n    else\n        mean_out[] = mean(tsshort)\n        std_out[] = std(tsshort)\n        ts_out .= (ts_in .- mean_out[])./std_out[]\n    end\nend\n\nnorm (generic function with 1 method)\n\n\n\nusing NetCDF\nindims = InDims(\"Time\")\nod_ts = OutDims(\"Time\",path = \"./normalized_ts.zarr\",\n                backend=:zarr,overwrite=true)\nod_m = OutDims(path = \"./means.nc\",backend=:netcdf, overwrite=true)\nod_s = OutDims(path = \"./stds.nc\",backend=:netcdf, overwrite=true)\noutdims = (od_ts, od_m, od_s)\ntsnorm, means, stds = mapCube(norm,c[Variable=Where(contains(\"temp\"))],indims=indims, outdims=outdims);\n\n\nheatmap(DimArray(stds[Variable=At(\"air_temperature_2m\")]))"
  },
  {
    "objectID": "intro_YAXArrays.html#apply-function-on-moving-window",
    "href": "intro_YAXArrays.html#apply-function-on-moving-window",
    "title": "General introduction to YAXArrays.jl and mapCube",
    "section": "Apply function on moving window",
    "text": "Apply function on moving window\n\nfunction meanfilter(xout, xin)\n    if ismissing(xin[2,2])\n        xout .= missing\n    else\n    xout .= mean(skipmissing(xin))\n    end\nend\n\nmeanfilter (generic function with 1 method)\n\n\n\nindims = InDims(MovingWindow(\"lon\", 1,1),MovingWindow(\"lat\", 1, 1))\n\nInDims((MovingWindow(YAXArrays.ByName(\"lon\"), 1, 1), MovingWindow(YAXArrays.ByName(\"lat\"), 1, 1)), Array, (YAXArrays.DAT.AllMissing(),), missing)\n\n\n\nheatmap(DimArray(means[Variable=At(\"air_temperature_2m\")]))\n\n\nstds\n\n\nfilteredmeans = mapCube(meanfilter, means, indims=indims, outdims=OutDims())\n\n\n144×72×3 YAXArray{Union{Missing, Float32},3} with dimensions: \n  Dim{:lon} Sampled{Float64} -178.75:2.5:178.75 ForwardOrdered Regular Points,\n  Dim{:lat} Sampled{Float64} -88.75:2.5:88.75 ForwardOrdered Regular Points,\n  Dim{:Variable} Categorical{String} String[\"max_air_temperature_2m\", \"air_temperature_2m\", \"min_air_temperature_2m\"] Unordered\nTotal size: 121.5 KB\n\n\n\n\n\nheatmap(DimArray(filteredmeans[Variable=At(\"air_temperature_2m\")]))"
  },
  {
    "objectID": "intro_YAXArrays.html#define-new-output-dimensions",
    "href": "intro_YAXArrays.html#define-new-output-dimensions",
    "title": "General introduction to YAXArrays.jl and mapCube",
    "section": "Define new output dimensions",
    "text": "Define new output dimensions\n\nusing Dates\ndateformatfun(x) = Dates.format.(rata2datetime.(x), \"mm/dd/yyyy\")\ngpp = c[Variable=At(\"gross_primary_productivity\"),\n        time=Date(2001)..Date(2018,12,31), \n        lon=Near(11.3464),lat=Near(46.4946)]\nfig,ax, pl = lines(datetime2rata.(lookup(gpp, Ti).data),gpp.data)\nax.xtickformat = dateformatfun\nfig\n\n\n\n\n\n\n\n\nSo far the function applied here were very simple statistics. Just to stress again, that we are running arbitrary Julia code here, so for example if we want to use some package for time series decomposition like Forecast.jl:\n\nusing Forecast\nstlres = stl(gpp.data[:],46,robust=true,verbose=false,\n            timestamp=lookup(gpp, Ti).data)\n\nLoadError: UndefVarError: `tempbozen` not defined\n\n\n\nfunction plot_stlres(t, org, stlres)\n    fig = Figure()\n    axorg = Axis(fig[1,1], title=\"Original data\")\n    axseas = Axis(fig[2,1], title=\"Seasonal\")\n    axtrend = Axis(fig[3,1], title=\"Trend\")\n    axrem = Axis(fig[4,1], title=\"Remainder\")\n    lines!(axorg,t, org)\n    lines!(axseas, t, stlres.decomposition[!,:Seasonal])\n    lines!(axtrend, t, stlres.decomposition[!, :Trend])\n    lines!(axrem, t, stlres.decomposition[!, :Remainder])\n    hidexdecorations!.([axorg, axseas, axtrend], grid=false)\n    axrem.xtickformat = dateformatfun\n    fig\nend\n\nplot_stlres (generic function with 2 methods)\n\n\n\nt = datetime2rata.(stlres.decomposition[!,:Timestamp])\nplot_stlres(t, gpp, stlres)\n\n\n\n\n\n\n\n\nIn order to apply this over a full array we define the usual Trio: indims, outdims and the function to be applied. Here we create a new dimension for the output. There are 2 types of axes in YAXArrays, CategoricalAxis for unordered and RangeAxis for ordered dimensions. Here we create a categorical axis for our outputs. This means that inside the function the input array xin is a vector with of length n_timesteps and the output is a matrix of size n_timesteps x 3\n\nimport Logging\nLogging.disable_logging(Logging.Info)\nindims = InDims(\"time\")\noutdims = OutDims(\"time\",Dim{:Scale}([\"Seasonal\", \"Trend\", \"Remainder\"]), \n                    path = \"decomposed.zarr\",backend=:zarr, overwrite=true)\nfunction decompose_TS(xout, xin)\n    any(isnan,xin) && return xout .= missing\n    stlres = stl(xin,46,robust=false,verbose=false)\n    _,seas,trend,rem = eachcol(stlres.decomposition)\n    xout[:,1] = seas\n    xout[:,2] = trend\n    xout[:,3] = rem\nend\n\ndecompose_TS (generic function with 1 method)\n\n\n\nusing Logging\nLogging.disable_logging(Warn)\n\n\n@time dec = mapCube(decompose_TS, \n    c[Variable=At(\"gross_primary_productivity\"),\n        time=Date(2001)..Date(2018,12,31),\n        region=\"Italy\"],\n        #lon=Near(11.3464),lat=Near(46.4946)],\n    indims = indims,\n    outdims = outdims\n)\n\nProgress: 100%|█████████████████████████████████████████| Time: 0:02:11\n\n\n131.577868 seconds (204.94 M allocations: 576.936 GiB, 22.72% gc time)\n\n\n\n782×3×48×46 YAXArray{Union{Missing, Float32},4} with dimensions: \n  Ti Sampled{DateTime} DateTime[2001-01-05T00:00:00, …, 2017-12-31T00:00:00] ForwardOrdered Irregular Points,\n  Dim{:Scale} Categorical{String} String[\"Seasonal\", \"Trend\", \"Remainder\"] Unordered,\n  Dim{:lon} Sampled{Float64} 6.625:0.25:18.375 ForwardOrdered Regular Points,\n  Dim{:lat} Sampled{Float64} 46.875:-0.25:35.625 ReverseOrdered Regular Points\nTotal size: 19.76 MB\n\n\n\n\n\nLogging.disable_logging(Debug)\n\nLogLevel(-999)\n\n\n\nfig, axseas, heatyax = lines( datetime2rata.(lookup(dec, Ti).data),\n    dec[lon=Near(11.3464),lat=Near(46.4946)].data[:,1])\nfig\n\n\n\n\n\n\n\n\n\nlines!(datetime2rata.(lookup(dec, Ti).data),\n    stlres.decomposition[!, :Seasonal])\nfig\n\n\n\n\n\n\n\n\nYou see that the resulting array is a 4-dimensional array including the newly created axis. Lets do some plots:\n\n#Compute variance and plot a map of seasonal variance\nscalevar = mapslices(var,dec,dims=\"Time\")\nscalerange = mapslices(x-&gt;maximum(x) - minimum(x), dec, dims=\"Time\")\n\n\n3×48×46 YAXArray{Union{Missing, Float32},3} with dimensions: \n  Dim{:Scale} Categorical{String} String[\"Seasonal\", \"Trend\", \"Remainder\"] Unordered,\n  Dim{:lon} Sampled{Float64} 6.625:0.25:18.375 ForwardOrdered Regular Points,\n  Dim{:lat} Sampled{Float64} 46.875:-0.25:35.625 ReverseOrdered Regular Points\nTotal size: 25.88 KB\n\n\n\n\n\nheatmap(DimArray(scalerange[scale=At(\"Seasonal\")]))\n\n\n\n\n\n\n\n\n\nheatmap(DimArray(scalevar[scale=At(\"Remainder\")]))"
  },
  {
    "objectID": "intro_YAXArrays.html#interpolate-data-on-finer-grids",
    "href": "intro_YAXArrays.html#interpolate-data-on-finer-grids",
    "title": "General introduction to YAXArrays.jl and mapCube",
    "section": "Interpolate data on finer grids",
    "text": "Interpolate data on finer grids\n\nusing Revise,EarthDataLab, DimensionalData,Rasters, Interpolations\n#c = esdd()\nds = open_dataset(joinpath(tutorialdir,\"esdc_subset2.zarr\"))\ntair = ds.air_temperature_2m\n\nnewlons = -179.95:0.1:179.95\nnewlats = -89.95:0.1:89.95\n\n#Option 1:\ntair1 = spatialinterp(tair,newlons,newlats, order =Quadratic())\n\ntair1[lon=10..15, lat=50..60]\n\ntair1italy = tair1[region=\"Italy\",time=Near(DateTime(2015,6,1))]\n\n\nheatmap(DimArray(tair[region=\"Italy\", time=Near(DateTime(2015,6,1))]))\n\n\n\n\n\n\n\n\n\nfiginterp, interpax, interpheat = heatmap(DimArray(tair1italy))\n\n\n\n\n\n\n\n\n\nusing Dates\nnewtimes = DateTime(1979):Day(1):DateTime(2021,12,31)\ntair2 = interpolatecube(tair,Dict(:time=&gt;newtimes), order=Dict(:time=&gt;Quadratic()))\ntair2Jan = tair2[time=DateTime(2001)..DateTime(2002,1,31), lon=Near(11.3464),lat=Near(46.4946)]\ntairJan = tair[time=DateTime(2001)..DateTime(2002,1,31), lon=Near(11.3464),lat=Near(46.4946)]\n\nfig, ax, pl = scatter(datetime2rata.(lookup(tair2Jan, Ti).data), tair2Jan.data[:],label=\"Interpolated\")\nscatter!(datetime2rata.(lookup(tairJan, Ti).data), tairJan.data[:], label=\"Original\")\nax.xtickformat = dateformatfun\naxislegend(ax)\nfig\n\nii = [(:time, 3)]\nai = nothing\nai = nothing\nai = 1\nii[ai] = (:time, 3)\nintorder = (NoInterp(), NoInterp(), Quadratic(Line(OnGrid())))"
  },
  {
    "objectID": "intro_YAXArrays.html#use-python-or-r-in-inner-function",
    "href": "intro_YAXArrays.html#use-python-or-r-in-inner-function",
    "title": "General introduction to YAXArrays.jl and mapCube",
    "section": "Use Python or R in inner function",
    "text": "Use Python or R in inner function\n\nusing PyCall\nscipyndimage = pyimport(\"scipy.ndimage\")\n\nPyObject &lt;module 'scipy.ndimage' from '/home/fcremer/.julia/conda/3/lib/python3.9/site-packages/scipy/ndimage/__init__.py'&gt;\n\n\n\nfunction gaussian_smooth(xout, xin)\n    missinds = ismissing.(xin)\n    smooth = scipyndimage.gaussian_filter(xin[.!missinds], sigma=4)\n    xout[.!missinds] .= smooth\nend\n\ngaussian_smooth (generic function with 1 method)\n\n\n\ngpp_bozen_2010 = c[lon=Near(11.3464),lat=Near(46.4946),\n    time = DateTime(2010)..DateTime(2011),\n    Variable=At(\"gross_primary_productivity\")]\n\n\n46-element YAXArray{Union{Missing, Float32},1} with dimensions: \n  Ti Sampled{DateTime} DateTime[2010-01-05T00:00:00, …, 2010-12-31T00:00:00] ForwardOrdered Irregular Points\nunits: W m-2\nTotal size: 184.0 bytes\n\n\n\n\n\nsmoothcube = mapCube(gaussian_smooth, gpp_bozen_2010, indims=InDims(\"time\"), outdims=OutDims(\"time\"))\n\n\n46-element YAXArray{Union{Missing, Float32},1} with dimensions: \n  Ti Sampled{DateTime} DateTime[2010-01-05T00:00:00, …, 2010-12-31T00:00:00] ForwardOrdered Irregular Points\nTotal size: 184.0 bytes\n\n\n\n\n\nfig, ax, l = lines(datetime2rata.(lookup(gpp_bozen_2010, Ti).data), gpp_bozen_2010[:], label=\"Original\")\nlines!(ax,datetime2rata.(lookup(smoothcube, Ti).data), smoothcube[:], label=\"Smooth\")\nax.xtickformat= dateformatfun\naxislegend(ax)\nfig"
  },
  {
    "objectID": "intro_YAXArrays.html#parellelize-the-data-processing",
    "href": "intro_YAXArrays.html#parellelize-the-data-processing",
    "title": "General introduction to YAXArrays.jl and mapCube",
    "section": "Parellelize the data processing",
    "text": "Parellelize the data processing"
  },
  {
    "objectID": "intro_YAXArrays.html#easy-parallelization-on-multiple-cores-and-multiple-nodes",
    "href": "intro_YAXArrays.html#easy-parallelization-on-multiple-cores-and-multiple-nodes",
    "title": "General introduction to YAXArrays.jl and mapCube",
    "section": "Easy parallelization on multiple cores and multiple nodes¶",
    "text": "Easy parallelization on multiple cores and multiple nodes¶\n\nUse threads on a single computer\nUse Distributed on multiple computers\nWorks also with ClusterManagers like SLURM\n\n\nusing Distributed, Zarr\naddprocs(4);\n\n\n@everywhere begin \n    using Pkg\n    Pkg.activate(\".\")\n    Pkg.instantiate()\n    #Pkg.status()\n    using YAXArrays, Statistics, NetCDF, Zarr\nend\n\n  Activating project at `~/Documents/conferences/202310_Bozen_OEMC_GW23`\n\n\n      From worker 12:     Activating project at `~/Documents/conferences/202310_Bozen_OEMC_GW23`\n      From worker 13:     Activating project at `~/Documents/conferences/202310_Bozen_OEMC_GW23`\n      From worker 10:     Activating project at `~/Documents/conferences/202310_Bozen_OEMC_GW23`\n      From worker 11:     Activating project at `~/Documents/conferences/202310_Bozen_OEMC_GW23`"
  },
  {
    "objectID": "intro-pkg.html#package-handling",
    "href": "intro-pkg.html#package-handling",
    "title": "Introduction to the Package Manager",
    "section": "Package handling",
    "text": "Package handling\n\nFurther reading",
    "crumbs": [
      "Home",
      "Julia Introduction",
      "Package Manager"
    ]
  },
  {
    "objectID": "intro_ndarrays.html#contrast-to-databases",
    "href": "intro_ndarrays.html#contrast-to-databases",
    "title": "Basics of multidimensional data analysis",
    "section": "Contrast to databases",
    "text": "Contrast to databases",
    "crumbs": [
      "Home",
      "Basics of multidimensional data analysis"
    ]
  },
  {
    "objectID": "intro_ndarrays.html#pyramid-example",
    "href": "intro_ndarrays.html#pyramid-example",
    "title": "Basics of multidimensional data analysis",
    "section": "Pyramid example",
    "text": "Pyramid example\n\n\n\n\n\nDatacubes in Julia",
    "crumbs": [
      "Home",
      "Basics of multidimensional data analysis"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Geospatial data cubes in Julia workshop",
    "section": "",
    "text": "This is the website of the “Geospatial data cubes in Julia workshop”.\nIn this tutorial we will explore how to analyse raster data which is larger than RAM."
  },
  {
    "objectID": "index.html#preparation",
    "href": "index.html#preparation",
    "title": "Geospatial data cubes in Julia workshop",
    "section": "Preparation",
    "text": "Preparation\nTo participate in the hands-on parts of the tutorial please install Julia on your device and instantiate a first environment to make sure that most Julia packages are already downloaded on your computer.\n\nInstallation of Julia\nWe recommend to use the juliaup installer for julia.\n\nWindowsMac or Linux\n\n\nYou can install juliaup via the windows store or by executing\nwinget install julia -s msstore\n\n\nTo install juliaup in Linux or Mac execute the following in a shell\ncurl -fsSL https://install.julialang.org | sh\n\n\n\n\n\nInstantiation of an initial environment\nFor the workshop we are going to use the environment that is available of the examples folder.\n\nManual downloadUse git\n\n\nYou can download the Project.toml file from https://github.com/JuliaDataCubes/datacubes_in_julia_workshop/blob/main/examples/Project.toml manually and save it in a new folder. Then change in a terminal to this folder.\n\n\nUse git to download the whole workshop material.\ngit clone https://github.com/JuliaDataCubes/datacubes_in_julia_workshop/\nChange to the examples folder in the datacubes_in_julia_workshop folder.\n\n\n\nNow that we have the Project.toml file downloaded we can run the following line in the terminal from the folder in which the Project.toml is located.\njulia -e 'using Pkg;Pkg.activate(\".\");Pkg.resolve();Pkg.precompile()'"
  },
  {
    "objectID": "index.html#day-1",
    "href": "index.html#day-1",
    "title": "Geospatial data cubes in Julia workshop",
    "section": "Day 1",
    "text": "Day 1\n\n\n\nTime\nTopic\n\n\n\n\n9:00\nIntroduction to Datacube analysis\n\n\n9:30\nIntroduction to Julia\n\n\n10:30\nBreak\n\n\n10:50\nExercise: Time series analysis + plotting"
  },
  {
    "objectID": "index.html#day-2",
    "href": "index.html#day-2",
    "title": "Geospatial data cubes in Julia workshop",
    "section": "Day 2",
    "text": "Day 2\n\n\n\nTime\nTopic\n\n\n\n\n9:00\nIntroduction to YAXArrays.jl\n\n\n9:45\nExercise: YAXArrays\n\n\n10:15\nBreak\n\n\n10:30\nExcursion: Datacubes in python\n\n\n10:45\nData preparation\n\n\n11:15\nPyramidScheme.jl"
  },
  {
    "objectID": "intro_julia.html#variables",
    "href": "intro_julia.html#variables",
    "title": "Introduction to Julia",
    "section": "Variables",
    "text": "Variables"
  },
  {
    "objectID": "intro_julia.html#data-types",
    "href": "intro_julia.html#data-types",
    "title": "Introduction to Julia",
    "section": "Data types",
    "text": "Data types"
  },
  {
    "objectID": "intro_julia.html#loops",
    "href": "intro_julia.html#loops",
    "title": "Introduction to Julia",
    "section": "Loops",
    "text": "Loops"
  },
  {
    "objectID": "intro_julia.html#functions",
    "href": "intro_julia.html#functions",
    "title": "Introduction to Julia",
    "section": "Functions",
    "text": "Functions"
  },
  {
    "objectID": "intro_julia.html#multiple-dispatch",
    "href": "intro_julia.html#multiple-dispatch",
    "title": "Introduction to Julia",
    "section": "Multiple Dispatch",
    "text": "Multiple Dispatch"
  },
  {
    "objectID": "intro_julia.html#passing-functions-to-functions",
    "href": "intro_julia.html#passing-functions-to-functions",
    "title": "Introduction to Julia",
    "section": "Passing functions to functions",
    "text": "Passing functions to functions"
  }
]